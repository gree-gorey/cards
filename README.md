## Входные данные
Входные данные находятся в файле [data.js](https://github.com/gree-gorey/cards/blob/master/js/data.js).
Входные данные представляют собой несортированный массив карточек.
Каждая карточка представляет из себя словарь.
Mapping для карточки (звездочками отмечены обязательные элементы):
```JavaScript
{
    "source": "Gerona Airport",  // ** начальный пункт билета
    "destination": "Stockholm",  // ** конечный пункт билета
    "type": "flight",  // ** тип транспортного средства
    "identifier": "SK455",  // номер рейса
    "gate": "458",  // номер выхода
    "seat": "3A",  // номер места
    "baggageInfo": "Baggage drop at ticket counter 344."  // инфо про багаж
}
```

## Пример вызова и использования
Пример вызова можно посмотреть в файле [implementation.js](https://github.com/gree-gorey/cards/blob/master/js/implementation.js).

```JavaScript
// создаем экземпляр класса хранилища,
// передав ему в качестве параметра наш массив с несортированными карточками
var myStorage = new Storage(data);

myStorage.sort();  // вызываем метод сортировки карточек; в результате создается связанный список

myStorage.setGenerator();  // устанавливаем переменные для работы генератора

// запускаем генератор, который обходит все экземпляры класса Card в связанном списке
for (var card of myStorage.routeGenerator()) {
    // вызываем для каждой карточки метод генерации сообщения
    console.log(card.generateMessage());
}
```


## Краткое описание алгоритма сортировки
Есть два словаря: словарь начальных пунктов, где по ключу-названию начального пункта будет храниться ссылка на объект-карточку, и, соответственно, такой же словарь конечных пунктов.
Производится обход всех карточек, поступивших на вход, для каждой создается объект и ссылка на него в двух словарях.
Дальше создаем связанный список.
Берем любую карточку (например, первую). Берем ее конечный пункт и ищем по нему в словаре начальных пунктов следующую карточку.
Если нашли — то в первую записываем ссылку на вторую и повторяем то же самое для второй карточки. Так до тех пор пока не достигнем конца маршрута.
Как только достигнут конец маршрута, мы возвращаемся к первой карточке и проделываем те же действия, но уже двигаясь в начало маршрута.
Берем начальный пункт текущей карточки, ищем его в словаре конечных пунктов, и т.д.
В результате образуется связанный список.
В объекте `Storage` хранится ссылка на первую карточку, и от нее по ссылкам можно дойти до конца маршрута.

## Время работы алгоритма сортировки
На вход подается массив из n карточек.
Производится обход этого массива (n операций). В каждую итерацию происходит:
* считывание карточки (~1 операция)
* создание объекта Card (~1 операция)
* создание ссылки в словаре начальных пунтктов (~1 операция)
* создание ссылки в словаре конечных пунтктов (~1 операция)
Итого на чтение и создание объектов Card нужно ~4n операций.

Дальше снова происходит обход всех карточек (n операций) уже для создания связанного списка. В каждую итерацию происходит:
* считывание объекта Card (~1 операция)
* поиск по ключу либо в словаре начальных, либо в словаре конечных пунктов (в зависимости от того, какая часть алгоритма выполняется в данный момент) (~1 операция)
* запись ссылки на следующую карточку в текущую (~1 операция)
* удаление ссылки из словаря конечных/начальных пунктов (~1 операция)
Итого на создание связанного списка требуется ~4n операций.

То есть в общей сложности порядка 8n операций, асимптотически время работы t = O(n).
Сделать асимптотически меньше операций невозможно, т.к. просто хотя бы на чтение всех карточек уже необходимо как минимум n операций.
Следовательно, предложенный алгоритм оптимален.